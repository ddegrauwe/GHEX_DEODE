

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Scope and objectives of GHEX &mdash; GHEX 0.1.0 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/cscs.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="Introduction" href="../introduction/introduction.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> GHEX
          

          
            
            <img src="../_static/not_a_logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/introduction.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Scope and objectives of GHEX</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#features">Features</a></li>
<li class="toctree-l2"><a class="reference internal" href="#type-of-interfaces">Type of interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="#context">Context</a></li>
<li class="toctree-l2"><a class="reference internal" href="#communication-pattern">Communication Pattern</a></li>
<li class="toctree-l2"><a class="reference internal" href="#communication-object">Communication Object</a></li>
<li class="toctree-l2"><a class="reference internal" href="#communicator">Communicator</a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">GHEX</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Scope and objectives of GHEX</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/scope/scope.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="scope-and-objectives-of-ghex">
<span id="scope"></span><h1>Scope and objectives of GHEX<a class="headerlink" href="#scope-and-objectives-of-ghex" title="Permalink to this headline">¶</a></h1>
<p><cite>GHEX</cite> is a C++ library to perform halo-update operations in mesh/grid applications in modern HPC
architecures. Domain decomposition refers to the technique that applications use to distribute the
work across different processes when numerically solving differential equations. For instance, see
the next figure for a schematic depiction of this idea.</p>
<div class="align-center figure" id="id1">
<a class="reference internal image-reference" href="../_images/domain_decomp.png"><img alt="This should not be visible" src="../_images/domain_decomp.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Fig. 1 </span><span class="caption-text">Example of Domain Decomposition. The physical domain, on the left, is split into 4 different
sub-domains. To allow for the computation to progress without having to remotely access every
single element that resides on a remote process, the application uses <strong>ghost regions</strong>, or
<strong>halos</strong> (in pink), that need to be updated whenever the computation requires accesss to that
region.  The blue arrows show the communication pattern, also referred in the manual as
<strong>halo-update</strong>, or <strong>halo-exchange</strong> operation.</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
<div class="align-center figure" id="id2">
<a class="reference internal image-reference" href="../_images/symmetric.png"><img alt="This should not be visible" src="../_images/symmetric.png" style="width: 300px;" /></a>
<p class="caption"><span class="caption-number">Fig. 2 </span><span class="caption-text">Traditional distributed memory data distribution: one process (MPI rank) is responsible for one
sub-domain of the decomposed domain.</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</div>
<div class="align-center figure" id="id3">
<a class="reference internal image-reference" href="../_images/oversubscription.png"><img alt="This should not be visible" src="../_images/oversubscription.png" style="width: 300px;" /></a>
<p class="caption"><span class="caption-number">Fig. 3 </span><span class="caption-text">Each process in a node can manage more than one sub-domain, for instance to achieve load
balancing (over-subscription).</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</div>
<div class="align-center figure" id="id4">
<a class="reference internal image-reference" href="../_images/multi_threads.png"><img alt="This should not be visible" src="../_images/multi_threads.png" style="width: 300px;" /></a>
<p class="caption"><span class="caption-number">Fig. 4 </span><span class="caption-text">The over-subscription can be a tool to improve the parallelization in each process by running
computations in independent threads.</span><a class="headerlink" href="#id4" title="Permalink to this image">¶</a></p>
</div>
<div class="align-center figure" id="id5">
<a class="reference internal image-reference" href="../_images/hybrid.png"><img alt="This should not be visible" src="../_images/hybrid.png" style="width: 300px;" /></a>
<p class="caption"><span class="caption-number">Fig. 5 </span><span class="caption-text">Using accelerators is certainly one of the most attractive options for running HPC applications
on current and near future platforms. The execution can be symmetric, or hybrid.</span><a class="headerlink" href="#id5" title="Permalink to this image">¶</a></p>
</div>
<p>The objective of <cite>GHEX</cite> is to enable halo-update operations</p>
<blockquote>
<div><ul class="simple">
<li><p>for traditional domain decomposed distributed memory applications (i.e., one domain per node)
either on CPUs or GPUs</p></li>
<li><p>for applications applying over-subscription on a node, either for latency hiding or for
exploiting multi-threading</p></li>
<li><p>for application exploiting hybrid systems (nodes with multiple address spaces and multiple
computing devices)</p></li>
<li><p>regardless of the specific representation of the grid/mesh (by using <em>adaptors</em>)</p></li>
<li><p>on architectures that provide access to transport mechanisms other than MPI (e.g., <code class="docutils literal notranslate"><span class="pre">UCX</span></code> and
<code class="docutils literal notranslate"><span class="pre">Libfabric</span></code>) whose performance may be higher</p></li>
</ul>
</div></blockquote>
<p>In order to accomplish all of the above, the interfaces to <cite>GHEX</cite> requires a non trivial amount of
work on the user side.  The reward for this work is: portability to multiple architectures, with and
without accelerators, with the possibility to exploit native transport mechanisms. Depending on the
complexity of the application, a user can easily adapt it to use different number of threads, or
different types of threads. <cite>GHEX</cite> can accommodate these requirements quite flexibly.</p>
<div class="section" id="features">
<h2>Features<a class="headerlink" href="#features" title="Permalink to this headline">¶</a></h2>
<p><cite>GHEX</cite> employs a number of different communication strategies to improve performance of information
exchange. In particular, the following features are available:</p>
<blockquote>
<div><ul class="simple">
<li><p>off-node access: use of a buffered communication for remote neighbors and reduction of the
amount of messages by coallescing data with the same destination into larger chunks</p></li>
<li><p>in-node access: taking advantage of direct memory access within a shared memory region when
run with multiple threads (native) or when run with multiple processes (through <em>xpmem</em>)</p></li>
<li><p>latency hiding: computation - communication overlap is possible through an explicit
future-like API</p></li>
<li><p>cache friendliness: structured grids are traversed in a cache-friendly way to avoid cache
misses when serializing/deserializing data (for remote connections) and when directly
accessing memory (for node-local connections)</p></li>
<li><p>avoid serialization: certain types of unstructured meshes can be configured such that
serialization on one side of the communication can be avoided</p></li>
<li><p>heterogeneity of data: different types of data (with different neighbor regions) may be
exchanged in one go</p></li>
<li><p>GPU accelerators: carefully tuned serialization kernels which exploit the bandwidth and
asynchronicity of execution</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="type-of-interfaces">
<h2>Type of interfaces<a class="headerlink" href="#type-of-interfaces" title="Permalink to this headline">¶</a></h2>
<p><cite>GHEX</cite> has a layered strctured. The user can enter at different layers, depending on their needs.
The highest level is the <code class="docutils literal notranslate"><span class="pre">halo</span> <span class="pre">exchange</span></code> level, where the user instructs <cite>GHEX</cite> to take a mesh or
grid representation and produce a <code class="docutils literal notranslate"><span class="pre">communication</span> <span class="pre">pattern</span></code> to then perform the halo update
operations.</p>
<p>In order to enable all the previously mentioned features, like oversusubscription, alternate
transport layers and hybrid computations, the steps to create a pattern and use it to communicate
can seem overly complicated. While we are working on shortening the number of steps to take for
simple cases, more complex cases seem to require these complications, and hence they cannot be
avoided. As we expect applications to become more and more complex in the future, we think the use
cases in which the interfaces provided by <cite>GHEX</cite> will increase and overshadow the traditional
distributed memory applications simply based on MPI.</p>
<p>The main concepts needed by <cite>GHEX</cite> are:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Context</strong> : Provides information to the application about network connectivity. A computing
node, that can be identified with a process (or an MPI rank, for instance) needs some
information about how it is connected to other processes.</p></li>
<li><p><strong>Communicator</strong>: Represents an end-point of a communication, and is obtained from the
context (this are hidden when using the halo-exchange facilities, this is why the description
is placed ath the end of the chapter).</p></li>
<li><p><strong>Communication Pattern</strong>: Provides application-specific neighbor conntectivity information
(encodes exposed halos for sending and receiving, for instance)</p></li>
<li><p><strong>Communication Object</strong>: Is responsible for executing communications by tying together
<em>Communication Pattern</em>, <em>Communicator</em>, and user-data.</p></li>
</ul>
</div></blockquote>
<p>The following figure depicts the different components and their interactions:</p>
<div class="align-center figure" id="id6">
<a class="reference internal image-reference" href="../_images/GHEXSWARCH.png"><img alt="This should not be visible" src="../_images/GHEXSWARCH.png" style="width: 300px;" /></a>
<p class="caption"><span class="caption-number">Fig. 6 </span><span class="caption-text">Traditional distributed memory data distribution: one process (MPI rank) is responsible for one
sub-domain of the decomposed domain.</span><a class="headerlink" href="#id6" title="Permalink to this image">¶</a></p>
</div>
<p>Domains, halo-generators, and data descriptors are provided by the users, while the light-blue boxes
are provided by the GHEX library. Some user provided components are also provided by GHEX if
their implementation is found on common infrastructures, for instance, in Cartesian grids, or
parmeteis partitioned graphs, or the Atlas library for meshing and domain decomposition by ECMWF.</p>
<p>All these components live in <strong>contexts</strong>, that are the only platform specific interfaces of GHEX.
This allows for the GHEX codes to be portable across architectures in the sense that the sections
of the code impacted by the different characteristics of the architectures are confined in limited
places that can be easily controlled.</p>
</div>
<div class="section" id="context">
<h2>Context<a class="headerlink" href="#context" title="Permalink to this headline">¶</a></h2>
<p>The context manages the underlying transport layer. Among its tasks are initialization, connectivity
setup, communication end-point management, network topology exploration. It is the first GHEX entity
that is created and the last that is being destroyed (enclosed only by MPI initialization and finalization).  Contexts maintain state information that the
<em>communicators</em> need in order to function. In other words, communicators (presented below) cannot
outlive the contexts from where they were obtained. Initialization of contexts is platform specific,
since different transport layers require different information in the setup phase. Contexts assumes
that MPI is already initialized at the time of initialization. An MPI communicator is passed to it as
first argument, while subsequent arguments may be required for non-MPI transport layers, such as UCX
and Libfabric.</p>
<p><cite>GHEX</cite> assumes the availabilty of an MPI library implementation on the platform.
While this is not strictly needed conceptually, the vast majority of HPC applications rely on MPI
(for instance by using PGAS languages or runtime-systems such as HPX) and, thus, we can take
advantage of the infrastructre provided through MPI for our implementation. This simplifies creation
of contexts and collection of information about which processes participate in the computation.
Therefore, the context requires an MPI Communicator as runtime argument, in addition to other
possible transport specific arguments.  The passed MPI Communicator will be cloned by the context.
For this reason the context should be destroyed before the call to <code class="docutils literal notranslate"><span class="pre">MPI_Finalize</span></code>.</p>
<p>Contexts are constructed for a specific <em>transport layer</em>. The available tranport layers are: MPI,
UCX, and Libfabric. The transport layer is represented by a <em>tag</em> passed as template argument to the
context type.</p>
<p>In order to guarantee uniform initilization of the contexts, which are highly platform dependent,
the user should not call the constructor of the context direcly, but instead the use should use a
factory, which returns a <code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code> to context object instantiated with the proper
transport layer. The syntax looks like this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifdef USE_UCX</span>
<span class="k">using</span> <span class="n">transport</span> <span class="o">=</span> <span class="n">gridtools</span><span class="o">::</span><span class="n">ghex</span><span class="o">::</span><span class="n">tl</span><span class="o">::</span><span class="n">ucx_tag</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">using</span> <span class="n">transport</span> <span class="o">=</span> <span class="n">gridtools</span><span class="o">::</span><span class="n">ghex</span><span class="o">::</span><span class="n">tl</span><span class="o">::</span><span class="n">mpi_tag</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">auto</span> <span class="n">context_ptr</span> <span class="o">=</span> <span class="n">gridtools</span><span class="o">::</span><span class="n">ghex</span><span class="o">::</span><span class="n">tl</span><span class="o">::</span><span class="n">context_factory</span><span class="o">&lt;</span><span class="n">transport</span><span class="o">&gt;::</span><span class="n">create</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="n">other_args</span><span class="p">);</span>
</pre></div>
</div>
<p>In the above example the use of <code class="docutils literal notranslate"><span class="pre">#ifdef</span></code> is an example of how code can be made portable by minimal
use of macros, and a recompilation.</p>
<p>From the context, additional information can be obtained, such as the
<code class="docutils literal notranslate"><span class="pre">context&lt;TransportTag&gt;::rank()</span></code>, which is the unique ID of the process in the parallel execution,
and ranges from 0 to <code class="docutils literal notranslate"><span class="pre">context&lt;TransportTag&gt;::size()</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
<p>A context object is instantiated by the processes, but different processes in a computation should
instantiate contexts in the same order. The contexts instatiated, one per process, form a kind of
<em>distributed context</em>, since they are <em>connected</em> to one another. Suppose we have the following
code, executed by a certain number <cite>P</cite> of processes:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">context_ptrA</span> <span class="o">=</span> <span class="n">gridtools</span><span class="o">::</span><span class="n">ghex</span><span class="o">::</span><span class="n">tl</span><span class="o">::</span><span class="n">context_factory</span><span class="o">&lt;</span><span class="n">transport</span><span class="o">&gt;::</span><span class="n">create</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">context_ptrB</span> <span class="o">=</span> <span class="n">gridtools</span><span class="o">::</span><span class="n">ghex</span><span class="o">::</span><span class="n">tl</span><span class="o">::</span><span class="n">context_factory</span><span class="o">&lt;</span><span class="n">transport</span><span class="o">&gt;::</span><span class="n">create</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
</pre></div>
</div>
<p>The instances of <code class="docutils literal notranslate"><span class="pre">context_ptrA</span></code> in the <cite>P</cite> processes form a distributed context, those instances
are connected to one another. The communicators (see below) obtained from it can communcate to one
another directly. The same for the communicators obtianed from <code class="docutils literal notranslate"><span class="pre">context_ptrB</span></code>. Communicators from
<code class="docutils literal notranslate"><span class="pre">context_ptrA</span></code> cannot communicate directly to communicators from <code class="docutils literal notranslate"><span class="pre">context_ptrB</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Thread safety:</strong> A context shall be created in a (process-)serial part of the code.
Usage of a context is thread-safe.</p>
</div>
</div>
<div class="section" id="communication-pattern">
<h2>Communication Pattern<a class="headerlink" href="#communication-pattern" title="Permalink to this headline">¶</a></h2>
<p>In order to perform halo-update operations, the user needs to provide information about the domain,
the domain decomposition, the sizes of the halos and the access to the data.
One of the most important aspects of <cite>GHEX</cite> is the choice of not imposing a domain decomposition
strategy, that would possibly result in sub-optimal solutions or not match the developer thinking process.
Instead, the user is providing descriptions of the above mentioned concepts as adaptors to their
implementation.  After all, domain
decomposed applications all have to refer to similar information, even though the encoding of this
information differs in all sorts of details in different applications.
The user of <cite>GHEX</cite> needs to provide standard functions that <cite>GHEX</cite> will call to gather/access the
necessary information, and these functions form a thin layer that interfaces the specific domain
decomposition implementation and <cite>GHEX</cite>. We are providing some components directly, in order to
facilitate the interfacing in the most common cases and showcase the approach.</p>
<p>The <em>communication pattern</em> itself encodes the neighbor information with respect to a
domain decomposition and halo shapes.
The way <cite>GHEX</cite> digests user input is through adaptor classes. Since structured and unstructured
grids are rather different, we have decieded to specialize all concepts and classes for either case. Let us
first look at the structured grids.</p>
<p>For a given application, the following concepts need to be implemented:</p>
<ul class="simple">
<li><p><strong>domain descriptor:</strong> a class which describes a domain which provide (at least) the following interface</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// this class must be (cheaply) copy constructible.</span>

<span class="k">public</span><span class="o">:</span> <span class="c1">// member types</span>
    <span class="k">using</span> <span class="n">domain_id_type</span>      <span class="o">=</span> <span class="p">...;</span>  <span class="c1">// a globally unique id type which can be compared</span>
    <span class="k">using</span> <span class="n">dimension</span>           <span class="o">=</span> <span class="p">...;</span>  <span class="c1">// A integral constant</span>
    <span class="k">using</span> <span class="n">coordinate_type</span>     <span class="o">=</span> <span class="p">...;</span>  <span class="c1">// An array-like type</span>

<span class="k">public</span><span class="o">:</span> <span class="c1">// member functions</span>
    <span class="n">domain_id_type</span> <span class="n">domain_id</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>     <span class="c1">// returns the id</span>
    <span class="k">const</span> <span class="n">coordinate_type</span><span class="o">&amp;</span> <span class="n">first</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// returns the coordinate to the first (physical)</span>
                                          <span class="c1">// point in global coordinates</span>
    <span class="k">const</span> <span class="n">coordinate_type</span><span class="o">&amp;</span> <span class="n">last</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>  <span class="c1">// returns the coordinate to the last (physical)</span>
                                          <span class="c1">// point in global coordinates</span>
</pre></div>
</div>
<p>Note that the constructors, or any additional functionality, are not shown here, since they are not needed by <cite>GHEX</cite>. The user of <cite>GHEX</cite> construct those and give the objects with those prescribed characteristics to <cite>GHEX</cite>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">domain_id_type</span></code> needs to be comparable, and at least operators <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> and <code class="docutils literal notranslate"><span class="pre">==</span></code> should be provided.</p>
<ul class="simple">
<li><p><strong>domain region</strong></p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="o">:</span> <span class="c1">// member functions</span>
    <span class="k">const</span> <span class="n">coordinate_type</span><span class="o">&amp;</span> <span class="n">first</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">coordinate_type</span><span class="o">&amp;</span> <span class="n">last</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>halo region</strong></p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="o">:</span> <span class="c1">// member functions</span>
    <span class="k">const</span> <span class="n">domain_region</span><span class="o">&amp;</span> <span class="n">local</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">domain_region</span><span class="o">&amp;</span> <span class="n">global</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>halo generator:</strong> a class which generates a halo given a domain descriptor, with the following
interface</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="o">:</span> <span class="c1">// member functions</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">halo_region</span><span class="o">&gt;</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">domain_descriptor</span><span class="o">&amp;</span> <span class="n">dom</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">halo_region</span> <span class="nf">intersect</span><span class="p">(</span><span class="k">const</span> <span class="n">domain_type</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">coordinate_type</span><span class="o">&amp;</span> <span class="n">first_a_local</span><span class="p">,</span>  <span class="k">const</span> <span class="n">coordinate_type</span><span class="o">&amp;</span> <span class="n">last_a_local</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">coordinate_type</span><span class="o">&amp;</span> <span class="n">first_a_global</span><span class="p">,</span> <span class="k">const</span> <span class="n">coordinate_type</span><span class="o">&amp;</span> <span class="n">last_a_global</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">coordinate_type</span><span class="o">&amp;</span> <span class="n">first_b_global</span><span class="p">,</span> <span class="k">const</span> <span class="n">coordinate_type</span><span class="o">&amp;</span> <span class="n">last_b_global</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>Creation of a pattern container:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">GridType</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Transport</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">HaloGenerator</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">DomainRange</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">make_pattern</span><span class="p">(</span><span class="n">context</span><span class="o">&lt;</span><span class="n">Transport</span><span class="o">&gt;&amp;</span> <span class="n">context</span><span class="p">,</span> <span class="n">HaloGenerator</span><span class="o">&amp;&amp;</span> <span class="n">hgen</span><span class="p">,</span> <span class="n">DomainRange</span><span class="o">&amp;&amp;</span> <span class="n">d_range</span><span class="p">);</span>
</pre></div>
</div>
<p>with <code class="docutils literal notranslate"><span class="pre">GridType</span></code> equal to <code class="docutils literal notranslate"><span class="pre">structured::grid</span></code>.</p>
<p>In the case of unstructured grids:</p>
</div>
<div class="section" id="communication-object">
<h2>Communication Object<a class="headerlink" href="#communication-object" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><strong>field descriptor:</strong></p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="o">:</span> <span class="c1">// member types</span>
    <span class="k">using</span> <span class="n">value_type</span>      <span class="o">=</span> <span class="p">...;</span> <span class="c1">// fields value type</span>
    <span class="k">using</span> <span class="n">arch_type</span>       <span class="o">=</span> <span class="p">...;</span> <span class="c1">// fields location (cpu or gpu)</span>
    <span class="k">using</span> <span class="n">dimension</span>       <span class="o">=</span> <span class="p">...;</span> <span class="c1">// integral constant with the number of dimensions</span>
                                 <span class="c1">// including possible additional dimensions due to</span>
                                 <span class="c1">// multiples components</span>
    <span class="k">using</span> <span class="n">layout_map</span>      <span class="o">=</span> <span class="p">...;</span> <span class="c1">// memory layout (gridtools::layout_map&lt;...&gt;)</span>
    <span class="k">using</span> <span class="n">coordinate_type</span> <span class="o">=</span> <span class="p">...;</span> <span class="c1">// an array-like type with basic arithmetic operations</span>

<span class="k">public</span><span class="o">:</span> <span class="c1">// queries</span>
    <span class="k">typename</span> <span class="nc">arch_traits</span><span class="o">&lt;</span><span class="n">arch_type</span><span class="o">&gt;::</span><span class="n">device_id_type</span> <span class="n">device_id</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">domain_id_type</span> <span class="nf">domain_id</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">coordinate_type</span><span class="o">&amp;</span> <span class="n">extents</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">coordinate_type</span><span class="o">&amp;</span> <span class="n">offsets</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">byte_strides</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">value_type</span><span class="o">*</span> <span class="nf">data</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">int</span> <span class="nf">num_components</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="nf">is_vector_field</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span> <span class="c1">// member functions</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">IndexContainer</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">pack</span><span class="p">(</span><span class="n">value_type</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">const</span> <span class="n">IndexContainer</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">);</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">IndexContainer</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">unpack</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">const</span> <span class="n">IndexContainer</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="communicator">
<h2>Communicator<a class="headerlink" href="#communicator" title="Permalink to this headline">¶</a></h2>
<p>A context generates and keeps communicators. A communicator represents the end-point of a
communication and is obtained from a context.  Communicators coming from different contexts cannot
communicate with one another, creating isolation of communications, which is useful for
program composition and creating abstractions.</p>
<p>To get a communicator, the user calls</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">comm</span> <span class="o">=</span> <span class="n">context_ptr</span><span class="o">-&gt;</span><span class="n">get_communicator</span><span class="p">();</span>
</pre></div>
</div>
<p>In order to keep the API simple, <code class="docutils literal notranslate"><span class="pre">get_communicator</span></code> will return a <em>new</em> communicator every time
the function is invoked. The function is thread safe, and each thread of the computation can call it
and obtain a unique communicator object. A thread should call <code class="docutils literal notranslate"><span class="pre">get_communicator</span></code> only to get the
communicator objects it needs and should <em>never</em> invoke <code class="docutils literal notranslate"><span class="pre">get_communicator</span></code> to retrieve a
previously generated communicator. The user is <em>responsible</em> for keeping the communicators alive for
the duration needed by the computation. <code class="docutils literal notranslate"><span class="pre">get_communicator</span></code> must be called once for each
communicator instance needed.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If an application is only concerned with avaialble high-level halo-exchange facilities
(implemented in the <em>patterns</em> and <em>communication objects</em>, see below), a communicator is never
directly used by the application.  The API of the communicator explained below may however be
used to implement more complex scenarios where the applcation does not follow the typical bulk
halo exchange strategy.</p>
</div>
<p>Once a communicator is obtained, it can be used to send messages to, and receive from, other
communicators obtained from the same distributed context, as explained in the previous Section.</p>
<p>Communicators can communicate with one-another by sending messages with tags. There are two types of
message exchanges: <cite>future based</cite> and <cite>call-back based</cite>. The destination of a message is a <code class="docutils literal notranslate"><span class="pre">rank</span></code>,
that identifies a process/context, and a <code class="docutils literal notranslate"><span class="pre">tag</span></code> is used to match a receive on that rank.</p>
<p>Communicators do not direcly communicate to one-another, they rather send a message to a <em>context</em>
and by using tag-matching the messages are delivered to the proper communicator requesting a particular tag. Communicators are
mostly needed to increase concurrency, since different channels can be multiplexed or demultiplexed,
depending on the characteristics of the transport layer.</p>
<p>For instance, when using the MPI transport layer, multiple <code class="docutils literal notranslate"><span class="pre">Isends</span></code> and <code class="docutils literal notranslate"><span class="pre">Irecvs</span></code> are issued by
different communicators, and the concurrency is managed by the MPI runtime system that should be
initialized with <code class="docutils literal notranslate"><span class="pre">MPI_THREAD_MULTI</span></code> option. In UCX we can exploit concurrency differently: each
communicator has its private end-point for sending, while the receives are all channeled through a single
end-point on the process. This choice was dictated by benchmarks that showed this solution was the
most efficient. The same code runs with MPI and UCX transport layers, despite a different way
of handling concurrency and addressing latency hiding.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>While this leaves the tag management to the user, it avoids unnecessary restrictions for the
avaialbe tags, which are a scarce resource in some implementations (that is, the tags only allow
the use of few bits). Identifying the communicators directly would have required predetermining
the number of bits to assign for the local identyfiers and the bits used for rank
identification, which can lead to potentially hard to catch bugs. We may revise this decision in
the future.</p>
</div>
<p>Let’s take a look at the main interfaces to exchange messages using communicators:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Message</span><span class="o">&gt;</span>
<span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">send</span><span class="p">(</span><span class="k">const</span> <span class="n">Message</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="n">rank_type</span> <span class="n">dst</span><span class="p">,</span> <span class="n">tag_type</span> <span class="n">tag</span><span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Message</span><span class="o">&gt;</span>
<span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">recv</span><span class="p">(</span><span class="n">Message</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="n">rank_type</span> <span class="n">src</span><span class="p">,</span> <span class="n">tag_type</span> <span class="n">tag</span><span class="p">);</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Message</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Neighs</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span> <span class="n">send_multi</span><span class="p">(</span><span class="n">Message</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="k">const</span> <span class="n">Neighs</span><span class="o">&amp;</span> <span class="n">neighs</span><span class="p">,</span> <span class="n">tag_type</span> <span class="n">tag</span><span class="p">);</span>
</pre></div>
</div>
<p>The first function sends a message to a given rank with a given tag. The message can be any class
with <code class="docutils literal notranslate"><span class="pre">.data()</span></code> member function returning a pointer to a region of <em>contiguous</em> memory of
<code class="docutils literal notranslate"><span class="pre">.size()</span></code> elements. Additionally, the message type has to expose a typedef <code class="docutils literal notranslate"><span class="pre">value_type</span></code>
identifiying the type of element that is sent. The function returns a future-like value that can be
checked using <code class="docutils literal notranslate"><span class="pre">.wait()</span></code> to check that the message has been sent (the future does not guarantee the
message has been delivered). This variant <strong>does not take ownership of the message</strong> (but refers to
the address of the memory only) and the user is responsible to keep the message alive until the
communication has finished.</p>
<p>Similarly, the second function reveives into a message, with the same requirements as before, and
returns a future that, when <code class="docutils literal notranslate"><span class="pre">.wait()</span></code> returns guarantee the message has been received.</p>
<p>The third function conveniently allows to send the same message to multiple neighbors, and returns a
vector of futures to wait on.</p>
<p>The communicator also has a secondary API where a user-defined callback may be registered, which is
called upon completion of the communication:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Message</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CallBack</span><span class="o">&gt;</span>
<span class="n">request_cb</span> <span class="n">send</span><span class="p">(</span><span class="n">Message</span><span class="o">&amp;&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="n">rank_type</span> <span class="n">dst</span><span class="p">,</span> <span class="n">tag_type</span> <span class="n">tag</span><span class="p">,</span> <span class="n">CallBack</span><span class="o">&amp;&amp;</span> <span class="n">callback</span><span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Message</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CallBack</span><span class="o">&gt;</span>
<span class="n">request_cb</span> <span class="n">recv</span><span class="p">(</span><span class="n">Message</span><span class="o">&amp;&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="n">rank_type</span> <span class="n">src</span><span class="p">,</span> <span class="n">tag_type</span> <span class="n">tag</span><span class="p">,</span> <span class="n">CallBack</span><span class="o">&amp;&amp;</span> <span class="n">callback</span><span class="p">);</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Message</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Neighs</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CallBack</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">request_cb</span><span class="o">&gt;</span> <span class="n">send_multi</span><span class="p">(</span><span class="n">Message</span><span class="o">&amp;&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="n">Neighs</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">neighs</span><span class="p">,</span> <span class="n">tag_type</span> <span class="n">tag</span><span class="p">,</span> <span class="k">const</span> <span class="n">CallBack</span><span class="o">&amp;</span> <span class="n">callback</span><span class="p">);</span>
</pre></div>
</div>
<p>Here, the functions accept callbacks that are called either after the message has been sent (not
necessarily delivered) or received, respectively. The requirements on the message type stay the same
as before, however, the type of the message will be type erased in the process and the callback must
expose the following signature:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">message_type</span> <span class="n">msg</span><span class="p">,</span> <span class="n">rank_type</span> <span class="n">rank</span><span class="p">,</span> <span class="n">tag_type</span> <span class="n">tag</span><span class="p">);</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">message_type</span></code> is a class defined by <cite>GHEX</cite> fulfilling the above message contract with
<code class="docutils literal notranslate"><span class="pre">value_type</span></code> being <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code>. Thus, the <code class="docutils literal notranslate"><span class="pre">msg</span></code> object provides access to the same data as the
message passed to <cite>GHEX</cite> originally, reinterpreted as raw memory.</p>
<p><cite>GHEX</cite> makes a distinction based on the type of the message which is passed to the functions above:</p>
<blockquote>
<div><ul class="simple">
<li><p>if the message is moved in (has r-value reference type), the communicator <strong>takes ownership of
the message</strong> and keeps the message alive internally. The user is free to delete or re-use the
(moved) message directly after calling the function.</p></li>
<li><p>if the message is passed by l-value reference, the same requirements apply as above: the
communicator <strong>does not take ownership of the message</strong> and the user is responsible to keep
the message alive until the communication has finished.</p></li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When the callback is invoked, the message ownership is again passed to the user, i.e. the user is
free to delete or re-use the message inside the callback body. However, when the user re-submits
a further callback based communication through the above API from with the callback (recursive
call) , the message must passed by r-value reference (through <code class="docutils literal notranslate"><span class="pre">std::move</span></code>).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since GHEX relies on move semantics of the message internally, the message type must not
re-allocate memory during move construction and the memory address of the data must remain
constant during the communication.</p>
</div>
<p>The send/recv functions accepting call-backs, also return request values that can be used to check
if an operation succeded. However, these requests may not be used like futures: they cannot be
waited upon. Instead, to progress the communication and ensure the completion, the communicator has
to be progressed explicitly:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">progress_status</span> <span class="nf">progress</span><span class="p">();</span>
</pre></div>
</div>
<p>This function progresses the transport layer and returns a status object. The status object can be
queried for the number of progressed send and receive callbacks.</p>
<p>A third API is provided for messages wrapped in a <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Message</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CallBack</span><span class="o">&gt;</span>
<span class="n">request_cb</span> <span class="n">send</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span> <span class="n">shared_msg_ptr</span><span class="p">,</span> <span class="n">rank_type</span> <span class="n">dst</span><span class="p">,</span> <span class="n">tag_type</span> <span class="n">tag</span><span class="p">,</span> <span class="n">CallBack</span><span class="o">&amp;&amp;</span> <span class="n">callback</span><span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Message</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CallBack</span><span class="o">&gt;</span>
<span class="n">request_cb</span> <span class="n">recv</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span> <span class="n">shared_msg_ptr</span><span class="p">,</span> <span class="n">rank_type</span> <span class="n">src</span><span class="p">,</span> <span class="n">tag_type</span> <span class="n">tag</span><span class="p">,</span> <span class="n">CallBack</span><span class="o">&amp;&amp;</span> <span class="n">callback</span><span class="p">);</span>
</pre></div>
</div>
<p>Here, the owenership is obviously shared between the user and <cite>GHEX</cite>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Thread safety:</strong> A communicator is thread-compatible, i.e. it is created per thread. One must
not use the same communicator from more than one thread.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="../introduction/introduction.html" class="btn btn-neutral float-left" title="Introduction" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2020, ETH Zurich.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>